import { supabase } from './supabaseClient'; // Adjust the import path as needed
import type { PostgrestError } from '@supabase/supabase-js';

// Define an interface for the structure of a saved prompt
export interface SavedPrompt {
  id: string;
  user_id: string;
  created_at: string;
  name?: string | null; // Added name property
  prompt_text: string;
  tone_id: string;
  context: string;
}

/**
 * Fetches all saved prompts for a specific user, ordered by creation date (newest first).
 * @param userId - The UUID of the user whose prompts are to be fetched.
 * @returns An array of saved prompts or an empty array on error
 */
export const fetchSavedPrompts = async (userId: string): Promise<SavedPrompt[]> => {
  // Ensure userId is provided
  if (!userId) {
    console.error('fetchSavedPrompts: userId is required.');
    return [];
  }

  try {
    // Query the saved_prompts table
    const { data, error } = await supabase
      .from('saved_prompts')
      .select('*') // Select all columns
      .eq('user_id', userId) // Filter by the provided user ID
      .order('created_at', { ascending: false }); // Order by creation date, newest first

    // Handle potential Supabase errors during the fetch
    if (error) {
      console.error('Error fetching saved prompts:', error);
      return [];
    }

    // Return the fetched data
    return data as SavedPrompt[] || []; // Type assertion
  } catch (err) {
    // Handle unexpected errors during the operation
    console.error('Unexpected error fetching saved prompts:', err);
    return [];
  }
};


// Define the input type for saving a new prompt (excluding fields generated by DB)
export interface NewSavedPromptData {
  user_id: string;
  label?: string | null; // Label is optional
  prompt_text: string;
  tone_id: string;
  context: string;
}

/**
 * Saves a new prompt to the saved_prompts table for the specified user.
 * @param promptData - An object containing the data for the new prompt.
 * @returns An object containing the newly saved prompt or an error.
 */
export const saveNewPrompt = async (
  promptData: NewSavedPromptData
): Promise<{ data: SavedPrompt | null; error: PostgrestError | null | string }> => {
  // Basic validation
  if (!promptData.user_id || !promptData.prompt_text || !promptData.tone_id || !promptData.context) {
    console.error('saveNewPrompt: Missing required fields in promptData.');
    return { data: null, error: 'Missing required information to save the prompt.' };
  }

  try {
    // Insert the new prompt data into the saved_prompts table
    // We use .select() to return the newly created row
    const { data, error } = await supabase
      .from('saved_prompts')
      .insert([
        {
          user_id: promptData.user_id,
          label: promptData.label, // Will be null if not provided
          prompt_text: promptData.prompt_text,
          tone_id: promptData.tone_id,
          context: promptData.context,
        },
      ])
      .select() // Return the inserted row(s)
      .single(); // Expecting only one row to be inserted and returned

    // Handle potential Supabase errors during the insert
    if (error) {
      console.error('Error saving new prompt:', error);
      // Provide a more specific message if it's a potential duplicate or constraint violation
      if (error.code === '23505') { // Unique violation, though unlikely with UUIDs unless label has unique constraint
          return { data: null, error: 'A prompt with this name might already exist.' };
      }
      return { data: null, error: 'Failed to save prompt. Please try again.' };
    }

    // Return the newly created prompt data
    return { data: data as SavedPrompt, error: null }; // Type assertion
  } catch (err) {
    // Handle unexpected errors during the operation
    console.error('Unexpected error saving new prompt:', err);
    const message = err instanceof Error ? err.message : 'An unexpected error occurred.';
    return { data: null, error: `Failed to save prompt: ${message}` };
  }
};


/**
 * Deletes a specific saved prompt belonging to the user.
 * @param promptId - The UUID of the prompt to delete.
 * @param userId - The UUID of the user attempting the deletion (for RLS verification).
 * @returns An object indicating success or containing an error message.
 */
export const deletePrompt = async (
  promptId: string,
  userId: string
): Promise<{ success: boolean; error: PostgrestError | null | string }> => {
  // Basic validation
  if (!promptId || !userId) {
    console.error('deletePrompt: Missing promptId or userId.');
    return { success: false, error: 'Missing required information to delete the prompt.' };
  }

  try {
    // Attempt to delete the prompt matching both the prompt ID and user ID
    // The RLS policy also ensures the user can only delete their own prompts,
    // but matching user_id here provides an extra layer and potentially clearer errors.
    const { error } = await supabase
      .from('saved_prompts')
      .delete()
      .match({ id: promptId, user_id: userId }); // Match both ID and user ID

    // Handle potential Supabase errors during deletion
    if (error) {
      console.error('Error deleting prompt:', error);
      return { success: false, error: 'Failed to delete prompt. Please try again.' };
    }

    // If no error occurred, the deletion was successful (or the prompt didn't exist/match)
    // Supabase delete doesn't error if the row doesn't exist based on the match criteria.
    return { success: true, error: null };
  } catch (err) {
    // Handle unexpected errors during the operation
    console.error('Unexpected error deleting prompt:', err);
    const message = err instanceof Error ? err.message : 'An unexpected error occurred.';
    return { success: false, error: `Failed to delete prompt: ${message}` };
  }
}; 